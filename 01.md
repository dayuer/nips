NIP-01
======

基本协议流描述
-------------------------------

`draft` `mandatory` `author:fiatjaf` `author:distbit` `author:scsibug` `author:kukks` `author:jb55`

本 NIP 定义了每个人都应该实现的基本协议。新的NIP可以在这里描述的结构和流程中添加新的可选（或强制）字段和消息以及功能。

## 事件和签名

每个用户都有一个密钥对。根据曲线 "secp256k1" 的 Schnorr 签名标准进行签名、公钥和编码 (https://bips.xyz/340)。

唯一存在的对象类型是 "event"，它在线上具有以下格式：

```json
{
  "id": <32 个字节的小写十六进制编码的 sha256 序列化事件数据>
  "pubkey": <32 个字节的小写十六进制编码的事件创建者的公钥>,
  "created_at": <unix 时间戳（以秒为单位）>,
  "kind": <整数>,
  "tags": [
    ["e", <32 个字节的另一个事件的 id 的十六进制>, <推荐的中继 URL>],
    ["p", <32 个字节的密钥的十六进制>, <推荐的中继 URL>],
    ... // 其他种类的标签可以在以后包含
  ],
  "content": <任意字符串>,
  "sig": <序列化事件数据的 sha256 哈希值的签名的 64 个字节十六进制，与 "id" 字段相同>
}

```

要获取 "event.id"，我们对序列化事件进行 "sha256" 运算。序列化是在以下结构的 UTF-8 JSON 序列化字符串（没有空格或换行）上进行的：

```json
[  0,
   <pubkey，十六进制字符串（小写）>,
   <created_at，数字>,
   <kind，数字>,
   <tags，非空字符串数组的数组>,
   <content，字符串>
]
```

## 客户端和中继之间的通信

中继向客户端提供一个 WebSocket 端点，客户端可以连接到此端点。

### 发送事件和创建订阅

客户端可以发送三种类型的消息，必须是根据以下模式的 JSON 数组：

  * `["EVENT", <event JSON as defined above>]`, 用于发布事件.
  * `["REQ", <subscription_id>, <filters JSON>...]`, 用于请求事件并订阅新更新.
  * `["CLOSE", <subscription_id>]`, 用于停止先前的订阅.


"<subscription_id>" 是一个随机字符串，用于表示订阅。

"<filters>" 是一个 JSON 对象，确定订阅中将发送哪些事件，它可以具有以下属性：


```json  
{
  "ids": <事件 ID 或前缀的列表>,
  "authors": <公钥或前缀的列表，事件的公钥必须是其中的一个>,
  "kinds": <种类数字的列表>,
  "#e": <在 "e" 标签中引用的事件 ID 的列表>,
  "#p": <在 "p" 标签中引用的公钥的列表>,
  "since": <整数 Unix 时间戳，事件必须比此新才能通过>,
  "until": <整数 Unix 时间戳，事件必须比此旧才能通过>,
  "limit": <初始查询中事件的最大数量>
}
```
  
收到 REQ 消息后，中继器应该查询其内部数据库，返回与过滤器匹配的事件，然后存储该过滤器并将所有未来接收到的事件再次发送到同一个WebSocket，直到WebSocket关闭。当收到相同的 <subscription_id> 的 CLOSE 事件或发送相同的 <subscription_id> 的新的 REQ，中继器应该覆盖以前的订阅。
  
过滤器属性中包含列表（如ids、kinds或#e）是具有一个或多个值的JSON数组。 至少其中一个数组的值必须与事件中相关字段匹配，以便该条件本身被视为匹配。 对于诸如kind的标量事件属性，事件中的属性必须包含在过滤器列表中。 对于诸如#e的标签属性，事件可能具有多个值，必须在事件和过滤器条件值中至少有一个项相同。


"ids"和"authors" 列表包含小写十六进制字符串，这些字符串可以是64个字符的完全匹配，也可以是事件值的前缀。 前缀匹配是指过滤器字符串是事件值的精确字符串前缀。使用前缀可以使查询大量值的过滤器更紧凑，并且可以为不希望披露确切作者或事件的客户提供一些隐私。

所有筛选条件必须匹配，才能使事件通过筛选，也就是说，多个条件被解释为“&&”条件。

一个REQ消息可以包含多个过滤器。在这种情况下，符合任何过滤器的事件都应该被返回，即多个过滤器应被解释为“||”条件。

The `limit` property of a filter is only valid for the initial query and can be ignored afterward. When `limit: n` is present it is assumed that the events returned in the initial query will be the latest `n` events. It is safe to return less events than `limit` specifies, but it is expected that relays do not return (much) more events than requested so clients don't get unnecessarily overwhelmed by data.

筛选器中的limit属性仅对初始查询有效，随后可以忽略。 当存在limit: n时，假设返回的初始查询的事件将是最新的n个事件。 返回的事件少于limit指定的事件是安全的，但期望中继不会返回（多）比请求更多的事件，以免客户不必要地被数据压垮。

### 从中继器到客户端：发送事件和通知

中继可以发送两种类型的消息，这些消息必须是按以下模式的 JSON 数组：

  * `["EVENT", <subscription_id>, <event JSON as defined above>]`,用于发送客户请求的事件.
  * `["NOTICE", <message>]`, 用于向客户发送人类可读的错误消息或其他信息.


本 NIP 没有定义关于如何发送或处理 NOTICE 消息的规则。

"EVENT" 消息必须仅与客户端之前启动的订阅（使用上面的 "REQ" 消息）相关的订阅 ID 一起发送。


## 基本事件种类

  - `0`：set_metadata：content 设置为字符串化的 JSON 对象 {name: <username>, about: <string>, picture: <url, string>}，描述创建事件的用户。当路由器获得相同 pubkey 的新事件时，它可以删除过去的 set_metadata 事件。
  - `1`: `text_note`: the `content` 设置为笔记的文本内容（用户想说的任何内容）。非纯文本笔记应该使用 NIP-16 中描述的种类 1000-10000。
  - `2`: `recommend_server`: 设置为事件创建者希望向其关注者推荐的路由器的 URL（例如，wss://somerelay.com）。

中继器可以选择以不同的方式处理不同的消息种类，它可以选择也可以不选择处理它不了解的种类的默认方法。

## 其他说明：

- 客户端不应该对每个中继打开多个 websocket。一个通道可以支持无限数量的订阅，因此客户端应该这样做。
- `tags` 数组可以存储标记标识符，作为每个子数组的第一个元素，以及任意信息（始终是字符串）。本 NIP 定义了"p" - 意味着"公钥"，指向事件中提到的某个人的公钥 - 和"e" - 意味着"事件"，指向此事件引用、回复或以某种方式涉及的事件的ID。
- "e" 和 "p"标签上的<recommended relay URL>项是可选的（可以设置为 ""）中继的URL，客户端可以尝试连接以从打标签的事件或其他事件中获取打标签的事件或其他事件。它可以被忽略，但它的存在是为了增加审查抵抗力，并使中继地址在客户端之间的传播更加流畅。
