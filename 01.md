NIP-01
======

Basic protocol flow description
-------------------------------

`draft` `mandatory` `author:fiatjaf` `author:distbit` `author:scsibug` `author:kukks` `author:jb55`

This NIP defines the basic protocol that should be implemented by everybody. New NIPs may add new optional (or mandatory) fields and messages and features to the structures and flows described here.

这个 NIP 定义了所有人都应该实现的基本协议。新的 NIP 可以向这里描述的结构和流程中添加新的可选（或强制）字段和消息以及功能。

## Events and signatures 事件和签名

Each user has a keypair. Signatures, public key, and encodings are done according to the [Schnorr signatures standard for the curve `secp256k1`](https://bips.xyz/340).

每个用户都有一个密钥对。签名、公钥，编码根据[曲线 secp256k1 的 Schnorr 签名标准](https://bips.xyz/340) 进行。

The only object type that exists is the `event`, which has the following format on the wire:

唯一存在的对象类型是 event，它在线上具有以下格式：

```json
{
  "id": <32-bytes lowercase hex-encoded sha256 of the the serialized event data>
  "pubkey": <32-bytes lowercase hex-encoded public key of the event creator>,
  "created_at": <unix timestamp in seconds>,
  "kind": <integer>,
  "tags": [
    ["e", <32-bytes hex of the id of another event>, <recommended relay URL>],
    ["p", <32-bytes hex of the key>, <recommended relay URL>],
    ... // other kinds of tags may be included later
  ],
  "content": <arbitrary string>,
  "sig": <64-bytes hex of the signature of the sha256 hash of the serialized event data, which is the same as the "id" field>
}
```

To obtain the `event.id`, we `sha256` the serialized event. The serialization is done over the UTF-8 JSON-serialized string (with no white space or line breaks) of the following structure:

获取 event.id 的方法是对序列化的事件进行 sha256。序列化是通过 UTF-8 JSON 序列化字符串 (没有空格或换行) 完成的，结构如下：

```json
[
  0,
  <pubkey, as a (lowercase) hex string>,
  <created_at, as a number>,
  <kind, as a number>,
  <tags, as an array of arrays of non-null strings>,
  <content, as a string>
]
```

## Communication between clients and relays 客户端和中继之间的通信

Relays expose a websocket endpoint to which clients can connect.

中继向客户端提供一个 WebSocket 端点，客户端可以连接到该端点。

### From client to relay: sending events and creating subscriptions 发送事件和创建订阅

Clients can send 3 types of messages, which must be JSON arrays, according to the following patterns:

客户端可以发送三种类型的消息，必须是根据以下模式的 JSON 数组：

  * `["EVENT", <event JSON as defined above>]`, used to publish events.
  * `["REQ", <subscription_id>, <filters JSON>...]`, used to request events and subscribe to new updates.
  * `["CLOSE", <subscription_id>]`, used to stop previous subscriptions.

`<subscription_id>` is a random string that should be used to represent a subscription.

`<filters>` is a JSON object that determines what events will be sent in that subscription, it can have the following attributes:

```json
{
  "ids": <a list of event ids or prefixes>,
  "authors": <a list of pubkeys or prefixes, the pubkey of an event must be one of these>,
  "kinds": <a list of a kind numbers>,
  "#e": <a list of event ids that are referenced in an "e" tag>,
  "#p": <a list of pubkeys that are referenced in a "p" tag>,
  "since": <an integer unix timestamp, events must be newer than this to pass>,
  "until": <an integer unix timestamp, events must be older than this to pass>,
  "limit": <maximum number of events to be returned in the initial query>
}
```

Upon receiving a `REQ` message, the relay SHOULD query its internal database and return events that match the filter, then store that filter and send again all future events it receives to that same websocket until the websocket is closed. The `CLOSE` event is received with the same `<subscription_id>` or a new `REQ` is sent using the same `<subscription_id>`, in which case it should overwrite the previous subscription.

收到 REQ 消息后，中继器应该查询其内部数据库并返回符合过滤器的事件，然后存储该过滤器并再次将所有未来收到的事件发送到同一个 WebSocket，直到 WebSocket 关闭。如果收到具有相同 <subscription_id> 的 CLOSE 事件或使用相同的 <subscription_id> 发送了新的 REQ，则应该覆盖以前的订阅。

Filter attributes containing lists (such as `ids`, `kinds`, or `#e`) are JSON arrays with one or more values.  At least one of the array's values must match the relevant field in an event for the condition itself to be considered a match.  For scalar event attributes such as `kind`, the attribute from the event must be contained in the filter list.  For tag attributes such as `#e`, where an event may have multiple values, the event and filter condition values must have at least one item in common.

过滤器属性包含列表（如ids，kinds或#e）是具有一个或多个值的JSON数组。至少一个数组的值必须与事件中相关字段匹配，以便该条件本身被视为匹配。对于诸如kind之类的标量事件属性，事件中的属性必须包含在过滤器列表中。对于诸如#e的标签属性，其中事件可能具有多个值，事件和过滤器条件的值必须至少共有一项。

The `ids` and `authors` lists contain lowercase hexadecimal strings, which may either be an exact 64-character match, or a prefix of the event value.  A prefix match is when the filter string is an exact string prefix of the event value.  The use of prefixes allows for more compact filters where a large number of values are queried, and can provide some privacy for clients that may not want to disclose the exact authors or events they are searching for.

"ids"和"authors"列表包含小写十六进制字符串，这些字符串可以是完全匹配的64个字符，也可以是事件值的前缀。前缀匹配是指过滤器字符串是事件值的确切字符串前缀。使用前缀可以在查询大量值时提供更紧凑的过滤器，并且可以为不希望泄露具体作者或事件的客户提供一些隐私。

All conditions of a filter that are specified must match for an event for it to pass the filter, i.e., multiple conditions are interpreted as `&&` conditions.

所有筛选条件必须匹配，才能使事件通过筛选，也就是说，多个条件被解释为“&&”条件。

A `REQ` message may contain multiple filters. In this case, events that match any of the filters are to be returned, i.e., multiple filters are to be interpreted as `||` conditions.

一个REQ消息可以包含多个过滤器。在这种情况下，符合任何过滤器的事件都应该被返回，即多个过滤器应被解释为“||”条件。

The `limit` property of a filter is only valid for the initial query and can be ignored afterward. When `limit: n` is present it is assumed that the events returned in the initial query will be the latest `n` events. It is safe to return less events than `limit` specifies, but it is expected that relays do not return (much) more events than requested so clients don't get unnecessarily overwhelmed by data.

过滤器的“limit”属性仅对初始查询有效，随后可以忽略。 当存在“limit：n”时，假定初始查询返回的事件是最新的“n”个事件。 返回的事件少于指定的“limit”是安全的，但是期望中继器不返回（太多）事件，因此客户不会因数据而不必要地被压倒。

### From relay to client: sending events and notices  从中继器到客户端：发送事件和通知

Relays can send 2 types of messages, which must also be JSON arrays, according to the following patterns:

中继器也可以发送 2 种类型的消息，这些消息也必须是 JSON 数组，按照以下模式：


  * `["EVENT", <subscription_id>, <event JSON as defined above>]`, used to send events requested by clients.
  * `["NOTICE", <message>]`, used to send human-readable error messages or other things to clients.

This NIP defines no rules for how `NOTICE` messages should be sent or treated.

本 NIP 不定义 NOTICE 消息如何发送或如何处理的规则。

`EVENT` messages MUST be sent only with a subscription ID related to a subscription previously initiated by the client (using the `REQ` message above).

`EVENT` 消息必须仅与客户端先前发起的订阅相关的订阅 ID 一起发送（使用上面的 REQ 消息）。


## Basic Event Kinds

  - `0`: `set_metadata`: the `content` is set to a stringified JSON object `{name: <username>, about: <string>, picture: <url, string>}` describing the user who created the event. A relay may delete past `set_metadata` events once it gets a new one for the same pubkey.
  - `1`: `text_note`: the `content` is set to the text content of a note (anything the user wants to say). Non-plaintext notes should instead use kind 1000-10000 as described in [NIP-16](16.md).
  - `2`: `recommend_server`: the `content` is set to the URL (e.g., `wss://somerelay.com`) of a relay the event creator wants to recommend to its followers.

A relay may choose to treat different message kinds differently, and it may or may not choose to have a default way to handle kinds it doesn't know about.

## Other Notes:

- Clients should not open more than one websocket to each relay. One channel can support an unlimited number of subscriptions, so clients should do that.
- The `tags` array can store a tag identifier as the first element of each subarray, plus arbitrary information afterward (always as strings). This NIP defines `"p"` — meaning "pubkey", which points to a pubkey of someone that is referred to in the event —, and `"e"` — meaning "event", which points to the id of an event this event is quoting, replying to or referring to somehow.
- The `<recommended relay URL>` item present on the `"e"` and `"p"` tags is an optional (could be set to `""`) URL of a relay the client could attempt to connect to fetch the tagged event or other events from a tagged profile. It MAY be ignored, but it exists to increase censorship resistance and make the spread of relay addresses more seamless across clients.
